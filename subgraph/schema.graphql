# Rootstock Timelock Management App - The Graph Schema
# This schema defines entities for indexing TimelockController governance operations

enum OperationStatus {
  PENDING
  READY
  EXECUTED
  CANCELLED
}

type TimelockController @entity {
  "Contract address (same as id)"
  id: Bytes!

  "Contract address (redundant for convenience)"
  address: Bytes!

  "Current minimum delay in seconds"
  minDelay: BigInt!

  "Total operations scheduled"
  operationCount: Int!

  "All operations scheduled in this timelock"
  operations: [Operation!]! @derivedFrom(field: "timelockController")

  "All roles in this timelock"
  roles: [Role!]! @derivedFrom(field: "timelockController")
}

type Operation @entity {
  "Unique operation identifier (bytes32 hash from hashOperation)"
  id: Bytes!

  "Sequential index for sorting (blockNumber * 1000000 + logIndex)"
  index: BigInt!

  "TimelockController contract that owns this operation"
  timelockController: TimelockController!

  "Single target for schedule(), null for scheduleBatch()"
  target: Bytes

  "Single value in wei for schedule(), null for batch"
  value: BigInt

  "Single encoded calldata for schedule(), null for batch"
  data: Bytes

  "Predecessor operation that must execute first (0x0 if none)"
  predecessor: Bytes!

  "Salt for operation ID uniqueness"
  salt: Bytes!

  "Delay in seconds before operation becomes executable"
  delay: BigInt!

  "Ready timestamp (scheduledAt + delay)"
  timestamp: BigInt!

  "Current status: PENDING, READY, EXECUTED, CANCELLED"
  status: OperationStatus!

  "When the operation was scheduled (block timestamp)"
  scheduledAt: BigInt!

  "Transaction hash that scheduled this operation"
  scheduledTx: Bytes!

  "Proposer who scheduled (must have PROPOSER_ROLE)"
  scheduledBy: Bytes!

  "When executed (null if not executed)"
  executedAt: BigInt

  "Transaction hash that executed (null if not executed)"
  executedTx: Bytes

  "Executor who executed (null if not executed)"
  executedBy: Bytes

  "When cancelled (null if not cancelled)"
  cancelledAt: BigInt

  "Transaction hash that cancelled (null if not cancelled)"
  cancelledTx: Bytes

  "Canceller who cancelled (null if not cancelled)"
  cancelledBy: Bytes

  "All calls in this operation (0 for single call stored in operation, 1+ for batch)"
  calls: [Call!]! @derivedFrom(field: "operation")
}

type Call @entity {
  "Composite ID: operationId-index (e.g., 0x123...abc-0)"
  id: Bytes!

  "Parent operation this call belongs to"
  operation: Operation!

  "Index within batch (from CallScheduled event)"
  index: Int!

  "Target contract to call"
  target: Bytes!

  "Value to send in wei (can be 0)"
  value: BigInt!

  "Encoded function calldata"
  data: Bytes!

  "Decoded function signature (if ABI available)"
  signature: String
}

type Role @entity {
  "Keccak256 hash of role name (bytes32)"
  id: Bytes!

  "Role hash (same as id, redundant for convenience)"
  roleHash: Bytes!

  "TimelockController this role belongs to"
  timelockController: TimelockController!

  "Admin role that can grant/revoke this role"
  adminRole: Role

  "Current number of members (updated on grant/revoke)"
  memberCount: Int!

  "All grant/revoke events for this role"
  assignments: [RoleAssignment!]! @derivedFrom(field: "role")
}

type RoleAssignment @entity {
  "Composite ID: roleHash-account-txHash"
  id: Bytes!

  "Role being granted or revoked"
  role: Role!

  "Account receiving or losing the role"
  account: Bytes!

  "true = RoleGranted, false = RoleRevoked"
  granted: Boolean!

  "When the event occurred (block timestamp)"
  timestamp: BigInt!

  "Block number of the event"
  blockNumber: BigInt!

  "Transaction hash that emitted the event"
  txHash: Bytes!

  "Address that called grantRole/revokeRole"
  sender: Bytes!
}
